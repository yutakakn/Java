/*
 * BineFrame.java - [Java Binary Editor]
 *
 */

import java.awt.*;
import java.awt.event.*;
import java.io.*;

/*
 * Windowクラス
 */
public class BineFrame extends Frame
{
	// Used for addNotify check.
	boolean fComponentsAdjusted = false;

	//{{DECLARE_CONTROLS
	java.awt.FileDialog openFileDialog1 = new java.awt.FileDialog(this);
	//}}

	//{{DECLARE_MENUS
	java.awt.MenuBar mainMenuBar = new java.awt.MenuBar();
	java.awt.Menu menu1 = new java.awt.Menu();
	java.awt.MenuItem newMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem openMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem closeMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem saveMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem saveAsMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem separatorMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem exitMenuItem = new java.awt.MenuItem();
	java.awt.Menu menu2 = new java.awt.Menu();
	java.awt.MenuItem cutMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem copyMenuItem = new java.awt.MenuItem();
	java.awt.MenuItem pasteMenuItem = new java.awt.MenuItem();
	java.awt.Menu menu4 = new java.awt.Menu();
	java.awt.CheckboxMenuItem checkboxMenuItem1 = new java.awt.CheckboxMenuItem("ASCII");
	java.awt.CheckboxMenuItem checkboxMenuItem2 = new java.awt.CheckboxMenuItem("SJIS");
	java.awt.CheckboxMenuItem checkboxMenuItem3 = new java.awt.CheckboxMenuItem("EUC");
	java.awt.Menu menu3 = new java.awt.Menu();
	java.awt.MenuItem menuItem1 = new java.awt.MenuItem();
	java.awt.MenuItem menuItem2 = new java.awt.MenuItem("-");
	java.awt.MenuItem aboutMenuItem = new java.awt.MenuItem();
	//}}
	
	
	/*
	 * 追加変数
	 */
	BinFile binfile;
	EditWindow editwindow;
	Scrollbar editbar;
	
	
	public BineFrame()
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.

		//{{INIT_CONTROLS
		setLayout(null);
		setSize(640,480);
		setVisible(false);
		openFileDialog1.setMode(FileDialog.LOAD);
		openFileDialog1.setTitle("Open target file");
		//$$ openFileDialog1.move(24,312);
		//}}
		
		/*
		 * コンポーネントの初期化
		 */
		setTitle(Bine.Title);
		 
		binfile = new BinFile();
		editwindow = new EditWindow(this);
		setLayout(new BorderLayout());
		add(editwindow, "Center");
		
        editbar = new Scrollbar(Scrollbar.VERTICAL, 0, 1, 0, Bine.AppHeight);
		//マウスポインタを上下矢印な形にする。
		editbar.setCursor(
		    Cursor.getPredefinedCursor(Cursor.N_RESIZE_CURSOR | Cursor.S_RESIZE_CURSOR)
		);
		editbar.setEnabled(false);
        add(editbar, "East");
		
		setSize(Bine.AppWidth, Bine.AppHeight);
		
		

		//{{INIT_MENUS
		menu1.setLabel("File");
		menu1.add(newMenuItem);
		newMenuItem.setLabel("New File");
		newMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_N,false));
		menu1.add(openMenuItem);
		openMenuItem.setLabel("Open...");
		openMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_O,false));
		menu1.add(closeMenuItem);
		closeMenuItem.setEnabled(false);
		closeMenuItem.setLabel("Close");
		menu1.add(saveMenuItem);
		saveMenuItem.setEnabled(false);
		saveMenuItem.setLabel("Save");
		saveMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_S,false));
		menu1.add(saveAsMenuItem);
		saveAsMenuItem.setEnabled(false);
		saveAsMenuItem.setLabel("Save As...");
		menu1.add(separatorMenuItem);
		separatorMenuItem.setLabel("-");
		menu1.add(exitMenuItem);
		exitMenuItem.setLabel("Exit");
		mainMenuBar.add(menu1);
		menu2.setLabel("Edit");
		menu2.add(cutMenuItem);
		cutMenuItem.setEnabled(false);
		cutMenuItem.setLabel("Cut");
		cutMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_X,false));
		menu2.add(copyMenuItem);
		copyMenuItem.setEnabled(false);
		copyMenuItem.setLabel("Copy");
		copyMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_C,false));
		menu2.add(pasteMenuItem);
		pasteMenuItem.setEnabled(false);
		pasteMenuItem.setLabel("Paste");
		pasteMenuItem.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_V,false));
		mainMenuBar.add(menu2);
		menu4.setLabel("Code");
		checkboxMenuItem1.setLabel("ASCII");
		checkboxMenuItem1.setState(false);
		menu4.add(checkboxMenuItem1);
		checkboxMenuItem2.setLabel("SJIS");
		checkboxMenuItem2.setState(false);
		menu4.add(checkboxMenuItem2);
		checkboxMenuItem3.setLabel("EUC");
		checkboxMenuItem3.setState(false);
		menu4.add(checkboxMenuItem3);
		mainMenuBar.add(menu4);
		menu3.setLabel("About");
		menu3.add(menuItem1);
		menuItem1.setLabel("Options");
		menu3.add(menuItem2);
		menu3.add(aboutMenuItem);
		aboutMenuItem.setLabel("Version...");
		mainMenuBar.add(menu3);
		//$$ mainMenuBar.move(0,312);
		setMenuBar(mainMenuBar);
		//}}
		
		
		//チェックボックスの初期化
		if (Bine.CharCode == Bine.ASCII_MODE) {
		       checkboxMenuItem1.setState(true);
		} else if (Bine.CharCode == Bine.SJIS_MODE) {
		       checkboxMenuItem2.setState(true);
		} else {
		       checkboxMenuItem3.setState(true);
		}
		

		//{{REGISTER_LISTENERS
		SymWindow aSymWindow = new SymWindow();
		this.addWindowListener(aSymWindow);
		SymAction lSymAction = new SymAction();
		openMenuItem.addActionListener(lSymAction);
		exitMenuItem.addActionListener(lSymAction);
		aboutMenuItem.addActionListener(lSymAction);
		newMenuItem.addActionListener(lSymAction);
		SymFocus aSymFocus = new SymFocus();
		closeMenuItem.addActionListener(lSymAction);
		SymItem lSymItem = new SymItem();
		checkboxMenuItem1.addItemListener(lSymItem);
		checkboxMenuItem2.addItemListener(lSymItem);
		checkboxMenuItem3.addItemListener(lSymItem);
		menuItem1.addActionListener(lSymAction);
		saveMenuItem.addActionListener(lSymAction);
		saveAsMenuItem.addActionListener(lSymAction);
		//}}
		
	}
	
	void init_app() {
		editwindow.initImage(Bine.maxAppWidth, Bine.maxAppHeight);
	}
	
	public BineFrame(String title)
	{
		this();
		setTitle(title);
	}

    /**
     * Shows or hides the component depending on the boolean flag b.
     * @param b  if true, show the component; otherwise, hide the component.
     * @see java.awt.Component#isVisible
     */
    public void setVisible(boolean b)
	{
		if(b)
		{
			setLocation(Bine.AppLeftX, Bine.AppLeftY);
		}
		super.setVisible(b);
	}

	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension d = getSize();

		super.addNotify();

		if (fComponentsAdjusted)
			return;

		// Adjust components according to the insets
		setSize(getInsets().left + getInsets().right + d.width, getInsets().top + getInsets().bottom + d.height);
		Component components[] = getComponents();
		for (int i = 0; i < components.length; i++)
		{
			Point p = components[i].getLocation();
			p.translate(getInsets().left, getInsets().top);
			components[i].setLocation(p);
		}
		fComponentsAdjusted = true;
	}


	class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosing(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			if (object == BineFrame.this)
				BineFrame_WindowClosing(event);
		}
	}

	void BineFrame_WindowClosing(java.awt.event.WindowEvent event)
	{
		// to do: code goes here.

		BineFrame_WindowClosing_Interaction1(event);
	}


	void BineFrame_WindowClosing_Interaction1(java.awt.event.WindowEvent event)
	{
		try {
			// QuitDialog Create and show as modal
			(new QuitDialog(this, true)).setVisible(true);
		} catch (Exception e) {
		}
	}

	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (object == openMenuItem)
				openMenuItem_ActionPerformed(event);
			else if (object == aboutMenuItem)
				aboutMenuItem_ActionPerformed(event);
			else if (object == exitMenuItem)
				exitMenuItem_ActionPerformed(event);
			else if (object == newMenuItem)
				newMenuItem_ActionPerformed(event);
			else if (object == closeMenuItem)
				closeMenuItem_ActionPerformed(event);
			else if (object == menuItem1)
				menuItem1_ActionPerformed(event);
			else if (object == saveMenuItem)
				saveMenuItem_ActionPerformed(event);
			else if (object == saveAsMenuItem)
				saveAsMenuItem_ActionPerformed(event);
		}
	}
	
	
	/*
	 * [New]項目の動作
	 */
	void newMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		newMenuItem_ActionPerformed_Interaction1(event);
			 
	}

	void newMenuItem_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
		try {
		    binfile.createNewFile();
		    
		    dumpBinary("", "UNTITLED");
		    
		    saveMenuItem.setEnabled(true);
		    saveAsMenuItem.setEnabled(true);
		    
		} catch (java.lang.Exception e) {
		}
	}
	

	/*
	 * [Open]項目の動作
	 */
	void openMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.

		openMenuItem_ActionPerformed_Interaction1(event);
	}

	void openMenuItem_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
		try {
			// OpenFileDialog Create and show as modal
		    int		defMode         = openFileDialog1.getMode();
		    String	defTitle        = openFileDialog1.getTitle();
		    String defDirectory     = openFileDialog1.getDirectory();
		    String defFile          = openFileDialog1.getFile();

		    openFileDialog1 = new java.awt.FileDialog(this, defTitle, defMode);
		    openFileDialog1.setDirectory(defDirectory);
		    openFileDialog1.setFile(defFile);
		    openFileDialog1.setVisible(true);
		    
		    dumpBinaryFromFD(openFileDialog1);
		    
		} catch (Exception e) {
		}
	}
	

	/*
	 * [Close]項目の動作
	 */
	void closeMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		closeMenuItem_ActionPerformed_Interaction1(event);
	}

	void closeMenuItem_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
		try {
	        this.closeMenuItem.setEnabled(false);  //close項目の無効化
	        
	        editwindow.closeFile();
	        init_window_caption();
	        
		    saveMenuItem.setEnabled(false);
		    saveAsMenuItem.setEnabled(false);
	        
		} catch (java.lang.Exception e) {
		}
	}

	/*
	 * [About]項目の動作
	 */
	void aboutMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.

		aboutMenuItem_ActionPerformed_Interaction1(event);
	}


	void aboutMenuItem_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
		try {
			// AboutDialog Create and show as modal
			(new AboutDialog(this, true)).setVisible(true);
		} catch (Exception e) {
		}
	}


	/*
	 * [Exit]項目の動作
	 */
	void exitMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.

		exitMenuItem_ActionPerformed_Interaction1(event);
	}


	void exitMenuItem_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
		try {
			// QuitDialog Create and show as modal
		    (new QuitDialog(this, true)).setVisible(true);
		} catch (Exception e) {
		}
	}
	
	class SymFocus extends java.awt.event.FocusAdapter
	{
		public void focusLost(java.awt.event.FocusEvent event)
		{
		}
	}

	/*
	 * [Options]項目の動作
	 */
	void menuItem1_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		menuItem1_ActionPerformed_Interaction1(event);
	}

	void menuItem1_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
		try {
			// ChangeEnv Create and show as modal
			(new ChangeEnv(this, true)).setVisible(true);
			
			editwindow.updateWindow();
		} catch (java.lang.Exception e) {
		}
	}
	
	
	/*========================================================================
	 * 新規追加メソッド
	 *
	 *------------------------------------------------------------------------
	 */
	 
	/*
	 * ファイルを読み込みダンプ形式で返す。
	 */
	void dumpBinaryFromFD(FileDialog fd) {
	    String path, name;
	    
	    path = fd.getDirectory();
	    name = fd.getFile();
	    
	    try {
	        if (binfile.load(path, name) == false)
	            return;
	        
	    } catch (IOException e) {
	        return;
	    }
	    
	    dumpBinary(path, name);
	    
		saveMenuItem.setEnabled(true);
		saveAsMenuItem.setEnabled(true);
	}
	
	void dumpBinary(String path, String name) {
	    //ここまで来れば正常に読み込めているはず
	    binfile.setFilePathName(path, name);
	    
	    this.closeMenuItem.setEnabled(true);  //close項目の有効化
	    
	    set_window_caption(path, name);
	    
	    /*
	    Bine.debugPrint("Dump Start");
	    for (int i = 0; i < binfile.get_length() ; i += 16) {
	        Bine.debugPrint(binfile.dispLine(i));
	    }
	    Bine.debugPrint("Dump end");
	    */
	    
	    editwindow.setFile(binfile, editbar);
	    editwindow.requestFocus();
	}
	
	//キャプション初期化
	void init_window_caption() {
	    setTitle(Bine.Title);
	}
	
	//キャプション更新
	void set_window_caption(String path, String name) {
	    setTitle(Bine.Title + " - " + path + name);
	}
	
	void set_modified_window_caption() {
	    setTitle(Bine.Title + " - " + binfile.getPathName() + binfile.getFileName() + "*");
	}

	class SymItem implements java.awt.event.ItemListener
	{
		public void itemStateChanged(java.awt.event.ItemEvent event)
		{
			Object object = event.getSource();
			if (object == checkboxMenuItem1)
				checkboxMenuItem1_ItemStateChanged(event);
			else if (object == checkboxMenuItem2)
				checkboxMenuItem2_ItemStateChanged(event);
			else if (object == checkboxMenuItem3)
				checkboxMenuItem3_ItemStateChanged(event);
		}
	}

	//[ASCII]項目をチェックした場合
	void checkboxMenuItem1_ItemStateChanged(java.awt.event.ItemEvent event)
	{
	    this.checkboxMenuItem1.setState(true);
	    this.checkboxMenuItem2.setState(false);
	    this.checkboxMenuItem3.setState(false);
	    
	    Bine.CharCode = Bine.ASCII_MODE;
	    editwindow.updateWindow();
	}

	//[SJIS]項目をチェックした場合
	void checkboxMenuItem2_ItemStateChanged(java.awt.event.ItemEvent event)
	{
	    this.checkboxMenuItem1.setState(false);
	    this.checkboxMenuItem2.setState(true);
	    this.checkboxMenuItem3.setState(false);
	    
	    Bine.CharCode = Bine.SJIS_MODE;
	    editwindow.updateWindow();
	}

	//[EUC]項目をチェックした場合
	void checkboxMenuItem3_ItemStateChanged(java.awt.event.ItemEvent event)
	{
	    this.checkboxMenuItem1.setState(false);
	    this.checkboxMenuItem2.setState(false);
	    this.checkboxMenuItem3.setState(true);
	    
	    Bine.CharCode = Bine.EUC_MODE;
	    editwindow.updateWindow();
	}


	/*
	 * [Save]項目の動作
	 */
	void saveMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		saveMenuItem_ActionPerformed_Interaction1(event);
	}

	void saveMenuItem_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
		String path = "", filename = "";
		FileOutputStream fw;
		
		try {
		    path = binfile.getPathName();
		    filename = binfile.getFileName();
		    
		    //セーブする
		    fw = new FileOutputStream(new File(path, filename));
		    binfile.writeFileData(fw);
		    
		    set_window_caption(path, filename);
		    
		    //Bine.debugPrint("Saving: " + path + filename + "(" + binfile.length + " bytes)");
		} catch (java.lang.Exception e) {
		    Bine.debugPrint("Write I/O error: " + path + filename);
		}
	}

	/*
	 * [Save As]項目の動作
	 */
	void saveAsMenuItem_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
		saveAsMenuItem_ActionPerformed_Interaction1(event);
	}

	void saveAsMenuItem_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
	{
		String path = "", filename = "";
		FileOutputStream fw;
		FileDialog saveDialog = new FileDialog(this, "Save As File", FileDialog.SAVE);
		
		try {
		    path = binfile.getPathName();
		    filename = binfile.getFileName();
		    
		    //ファイルダイアログを開く
		    saveDialog.setDirectory(path);
		    saveDialog.setFile(filename);
		    saveDialog.setVisible(true);
		    
		    //セーブする
		    path = saveDialog.getDirectory();
		    filename = saveDialog.getFile();
		    
		    fw = new FileOutputStream(new File(path, filename));
		    binfile.writeFileData(fw);
		    
		    set_window_caption(path, filename);
		    binfile.setFilePathName(path, filename);
		    
		    //Bine.debugPrint("Saving: " + path + filename + "(" + binfile.length + " bytes)");
		} catch (java.lang.Exception e) {
		    //Bine.debugPrint("Write I/O error: " + path + filename);
		}
	}
}

/*
 * バイナリファイル操作クラス
 */
class BinFile
{
    byte data[];  //ファイルの内容
    int length;   //ファイルのサイズ
    boolean rightcut;  //漢字分断フラグ
    String pathname, filename; //パスとファイル名
    
    public BinFile() {
    }
    
    public void setFilePathName(String path, String file) {
        pathname = path;
        filename = file;
    }
    
    public String getPathName() {
        return (pathname);   
    }
    
    public String getFileName() {
        return (filename);   
    }
    
    public void writeFileData(FileOutputStream fw) throws IOException {
        fw.write(data, 0, length);
    }
    
    
    int get_length() {
        return (length);   
    }
    
    byte getData(int offset) throws ArrayIndexOutOfBoundsException {
        return (data[offset]);   
    }
    
    void setData(int offset, byte value) throws ArrayIndexOutOfBoundsException {
        data[offset] = value;
    }
    
    void insertData(int offset, byte value) throws ArrayIndexOutOfBoundsException {
        byte newdata[];
        
        if (offset >= length) {
            throw new ArrayIndexOutOfBoundsException();  //例外を投げる
        }
        
        length++;
        newdata = new byte[length];
        if (offset > 0) {
            System.arraycopy(data, 0, newdata, 0, offset);
        }
        newdata[offset] = value;
        System.arraycopy(data, offset, newdata, offset + 1, length - 1 - offset);
        data = newdata;
    }
    
    public boolean load(String path, String filename) throws IOException {
        File file = new File(path, filename);
        
        //ファイルとして読めるかどうかチェック
        if (file.canRead() == false) 
            return false;
        
        length = (int)file.length();   
        data = new byte[length];
        
        FileInputStream fin = new FileInputStream(file);
        fin.read(data, 0, length);
        fin.close();
        
        rightcut = false;
        
        return true; 
    }
    
    void createNewFile() {
        length = 1;
        data = new byte[length];
        
        rightcut = false;
    }
    
    void closeFile() {
        length = 0; 
        data = null;
    }
    
    //指定したアドレスから16バイト分フォーマットする
    public String dispLine(int addr) {
        String hex = "0123456789ABCDEF";
        String line, s;
        int i, bin_cnt;
        byte bin[] = new byte[16];
        byte nextbyte;
        boolean rightcut[] = new boolean[1];
        
        //アドレスの表示（32bit）
        s = "";
        for (i = 0; i < 8 ; i++) {
            s = s + hex.charAt( (addr >> (28 - 4*i)) & 0xf );
        }
        line = s + "  ";
        
        s = "";
        //16進表示
        bin_cnt = 0;
        for (i = addr ; i < addr + 16 ; i++) {
            if (i > length - 1) { //ファイルの終端を超えた場合
                s += "   ";
                bin[i - addr] = 0;
            } else {
                s = s + hex.charAt((data[i] >> 4) & 0xf) + hex.charAt(data[i] & 0xf);
                if (i - addr == 7 && i < length - 1) { //7-8バイト目の区切り
                    s += "-";
                } else {
                    s += " ";
                }
                bin[i - addr] = data[i];
                bin_cnt++;
            }
        }
        line += s + " ";
        
        //次行のバイトがあれば取得しておく（分断対策）
        if (addr + 16 <= length - 1) {
            nextbyte = data[addr + 16];
        } else {
            nextbyte = 0;
        }
        
        //文字表示
        switch (Bine.CharCode) {
        case Bine.SJIS_MODE:
            s = showKanjiSJIS(bin, bin_cnt, nextbyte);
            break;
            
        case Bine.EUC_MODE:
            s = showKanjiEUC(bin, bin_cnt, nextbyte);
            break;
       
        case Bine.ASCII_MODE:
        default:    
            s = showAscii(bin, bin_cnt);
            break;
        }
        
        line += s;
        
        return (line);
    }
    
    /*
     * ASCIIコードによる表示
     */
    boolean isAscii(byte code) {
        if (code >= 0x20 && code <= 0x7f)
             return true;
        return false;    
    }

    String showAscii(byte bin[], int cnt) {
        char str[] = new char[16];
        int i;
        
        for (i = 0 ; i < cnt ; i++) {
            if (isAscii(bin[i])) {
                str[i] = (char)bin[i];
            } else {
                str[i] = '.';
            }
        }
        for (i = cnt ; i < 16 ; i++) {
            str[i] = ' ';   
        }
        return (new String(str));
    }
    
    /*
     * S-JIS漢字コードによる表示
     */
    boolean isKanji(byte data) {
        int code = data & 0xff;
        
        if ((code >= 0x81 && code <= 0x9f) || (code >= 0xe0 && code <= 0xfc))
            return true;
        return false;   
    }
    
    boolean isKanji2(byte data) {
        int code = data & 0xff;
        
        if ((code >= 0x40 && code <= 0x7e) || (code >= 0x80 && code <= 0xfc))
            return true;
        return false;   
    }
    
    char getAscii(byte code) {
        if (isAscii(code)) {
            return (char)code;
        } else {
            return '.';
        }
    }
    
    //byte列から指定したエンコードでUnicodeへ変換する。
    char convertUnicode(byte code[], String enc) {
        String kstr;
        char conv[];
        
        try {
            //byte[2] -> 1文字のStringへ変換する。
            kstr = new String(code, enc);
            conv = kstr.toCharArray();
            return (conv[0]);
            
        } catch (UnsupportedEncodingException ex) {
            //Bine.debugPrint("Encoding failure: " + enc);
        }
        return 0;  //エラー
    }
    
    String showKanjiSJIS(byte bin[], int cnt, byte nextbyte) {
        char str[] = new char[16];
        int i, inkanji, str_pos;
        byte first = 0;
        byte kcode[] = new byte[2];
        String encodename = "SJIS";
        
        if (rightcut) {
            bin[0] = 0x20;   
        }
        rightcut = false;
        
        
        str_pos = 0;
        
        inkanji = 0;
        for (i = 0 ; i < cnt ; i++) {
            if (inkanji == 1) { // 漢字2バイト目
                char ret = 0;
                
                inkanji = 0;
                
                if (isKanji2(bin[i])) {
                    // まともなSJIS漢字の場合
                    kcode[0] = first;
                    kcode[1] = bin[i];
                    
                    ret = convertUnicode(kcode, encodename);
                }
                
                if (ret != 0) {
                    str[str_pos++] = ret;
                } else {
                    str[str_pos++] = getAscii(first);
                    str[str_pos++] = getAscii(bin[i]);
                }
                
            } else if (isKanji(bin[i])) { // 漢字1バイト目
                first = bin[i];
                inkanji = 1;
                
            } else { // ASCII
                str[str_pos++] = getAscii(bin[i]);
            }
        }
        
        //右端分断の場合
        if (inkanji == 1) {
            if (nextbyte != 0) {
                char ret;
                
                kcode[0] = first;
                kcode[1] = nextbyte;
                ret = convertUnicode(kcode, encodename);
                if (ret != 0) {
                    str[str_pos++] = ret;
                    
                    rightcut = true;
                    
                } else {
                    str[str_pos++] = getAscii(first);
                    str[str_pos++] = getAscii(bin[i]);
                }
            } else {
                str[str_pos++] = getAscii(first);
            }
        }
        
        for (i = str_pos ; i < 16 ; i++) {
            str[i] = ' ';   
        }
        
        return (new String(str));
    }
    
    
    /*
     * EUC漢字コードによる表示
     */
    boolean isEuc(byte data) {
        int code = data & 0xff;
        
        if ((code >= 0xA1 && code <= 0xFE))
            return true;
        return false;   
    }
    
    String showKanjiEUC(byte bin[], int cnt, byte nextbyte) {
        char str[] = new char[16];
        int i, inkanji, str_pos;
        byte first = 0;
        byte kcode[] = new byte[2];
        String encodename = "EUCJIS";
        //String encodename = "EUC_JP";
        
        if (rightcut) {
            bin[0] = 0x20;   
        }
        rightcut = false;
        
        str_pos = 0;
        
        inkanji = 0;
        for (i = 0 ; i < cnt ; i++) {
            if (inkanji == 1) { // 漢字2バイト目
                char ret = 0;
                
                inkanji = 0;
                
                if (isEuc(bin[i])) {
                    // まともなSJIS漢字の場合
                    kcode[0] = first;
                    kcode[1] = bin[i];
                    
                    ret = convertUnicode(kcode, encodename);
                }
                
                if (ret != 0) {
                    str[str_pos++] = ret;
                } else {
                    str[str_pos++] = getAscii(first);
                    str[str_pos++] = getAscii(bin[i]);
                }
                
            } else if (isEuc(bin[i])) { // 漢字1バイト目
                first = bin[i];
                inkanji = 1;
                
            } else { // ASCII
                str[str_pos++] = getAscii(bin[i]);
            }
        }
        
        //右端分断の場合
        if (inkanji == 1) {
            if (nextbyte != 0) {
                char ret;
                
                kcode[0] = first;
                kcode[1] = nextbyte;
                ret = convertUnicode(kcode, encodename);
                if (ret != 0) {
                    str[str_pos++] = ret;
                    
                    rightcut = true;
                    
                } else {
                    str[str_pos++] = getAscii(first);
                    str[str_pos++] = getAscii(bin[i]);
                }
            } else {
                str[str_pos++] = getAscii(first);
            }
        }
        
        for (i = str_pos ; i < 16 ; i++) {
            str[i] = ' ';   
        }
        
        return (new String(str));
    }
    
}

/*
 * 編集画面クラス
 */
class EditWindow extends Canvas
{
    Image offImg = null;
    Graphics offG = null;
    
    BinFile binfile = null;  //バイナリファイル操作クラス
    
    KeyEdit keyedit = null;  //キー入力クラス
    int cursor;
    boolean overwritemode;
    
    AnimateCursor animcursor = null;
    
    Scrollbar scrollbar = null;
    int filesize; //ファイルサイズ
    int start_line = 0; //表示開始ライン
    
    Font fnt;
    FontMetrics fm;
    int font_width, font_height, baseline;
    
    SymKey symkey;
    SymScroll symscroll;
    int block_line;
    int max_line;
    int visible_line;
    int draw_lines;
    
    static final int CursorTimer = 500;   //ミリ秒
    
    BineFrame parent;
    
    public EditWindow(BineFrame parent) {
        this.parent = parent;
        
        update_info();
        
        setBackground(Bine.DefColor);
    }
    
    void update_info() {
        //★メモ
        //Javaのフォント指定は少し複雑。FontMetrics APIヘルプに図解あり。
        fnt = new Font(Bine.FontName, Font.PLAIN , Bine.FontSize);
        fm = getFontMetrics(fnt);
        font_width = fm.charWidth('A');
        baseline = fm.getAscent();
        
        //Java2で試すと文字の縦幅が思うように取得できないようなので苦肉の策(-_-;)
        if (Bine.Java2VM) { // Java2の場合
            font_height = fm.getAscent();
        } else {
            font_height = fm.getHeight();
        }
    }
    
    void initImage(int ws, int hs) {
        offImg = createImage(ws, hs);
        offG = offImg.getGraphics();
    }
    
    void setFile(BinFile binfile, Scrollbar editbar) {
        this.binfile = binfile;   
        this.filesize = binfile.get_length();
        this.scrollbar = editbar;
        
        start_line = 0;
        block_line = 0;
        max_line = 0;
        visible_line = 0;
        
        update_info();
        
        if (keyedit != null) {
            this.removeKeyListener(keyedit);
        }
        this.addKeyListener(keyedit = new KeyEdit());
        
        cursor = 0;
        overwritemode = true;
        
        if (animcursor != null) {
            animcursor.halt();
            animcursor = null;
        }
        animcursor = new AnimateCursor();
        animcursor.start();
        
        setBackground(Color.white);
        
        updateWindow(); //画面へ反映させる
    }
    
    void closeFile() {
        binfile.closeFile();
        binfile = null;
        
        if (keyedit != null) {
            this.removeKeyListener(keyedit);
        }
        keyedit = null;
        
        animcursor.halt();
        animcursor = null;
        
        if (scrollbar != null) {
            scrollbar.setEnabled(false);
        }
        if (offG != null ) {
            int width, height;
            
            width = getSize().width;
            height = getSize().height;
            offG.setPaintMode();
            offG.setColor(Bine.DefColor); 
            offG.fillRect(0, 0, width, height);
            setBackground(Bine.DefColor);
            updateWindow();
        }
    }

    public void update(Graphics g) {
        if (offImg != null) {
            g.drawImage(offImg, 0, 0, this);
        }
    }
    
    public void paint(Graphics g) {
        update(g);
    }
    
    public void updateWindow() {
        update_info();
        drawInit(offG);
        repaint();
    }
    
    void limitedUpdateWindow(int x, int y, int w, int h) {
        drawInit(offG);
        repaint(x, y, w, h);
    }
    
    void drawInit(Graphics g) {
        int offset;
       
        //ファイルがまだ読み込まれていない
        if (binfile == null)
            return;
            
        if (offImg == null || g == null)
            return;
            
        drawHexDump(g);
        
        //スクロールバーを出現させる
        filesize = binfile.get_length();
        if (start_line > 0 || draw_lines*16 < filesize) {
            int sdiv = Bine.ScrollLine;
            
            max_line = filesize / 16 + 1; //全行数を計算
            offset = start_line; 
            block_line = draw_lines / sdiv;
            //visible_line =  draw_lines * draw_lines / max_line; バグ
            visible_line = 1;
            
            /* 
            Bine.debugPrint("maxline"+max_line+" offset"+offset+
                " block"+block_line+ " v_line" + visible_line + 
                " draw_lines"+draw_lines);
               */ 
            
            //スクロールバーへの各種設定
            /* 実際にスクロールできる範囲は 0 〜 (max_line - draw_lines)
             * となる。
             */
            scrollbar.setBlockIncrement(block_line);
            scrollbar.setMaximum(max_line);
            scrollbar.setValue(offset);
            scrollbar.setVisibleAmount(draw_lines);
            
            if (symscroll != null) {
                scrollbar.removeAdjustmentListener(symscroll);
                symscroll = null;
            }
            if (symscroll == null) {
                scrollbar.addAdjustmentListener(symscroll = new SymScroll()); //handler
            }
            
            scrollbar.setEnabled(true);
            //scrollbar.setVisible(true);
            
            if (symkey != null) {
                this.removeKeyListener(symkey);
                symkey = null;
            }
            if (symkey == null) {
                this.addKeyListener(symkey = new SymKey()); //key handler
            }
            
            //Bine.debugPrint("true");
        } else { //消す
            scrollbar.setEnabled(false);
            block_line = 0;
            
            if (symkey != null) {
                this.removeKeyListener(symkey);
                symkey = null;
            }
            if (symscroll != null) {
                scrollbar.removeAdjustmentListener(symscroll);
                symscroll = null;
            }
            
            //Bine.debugPrint("false");
        }
        
    }
    
    synchronized void drawHexDump(Graphics g) {
        int width, height, i, addr;
        
        g.setFont(fnt);
        g.setPaintMode();  //上書きペイントモード
        
        //ユーザがWindowの大きさを変更するかもしれないので、
        //Windowサイズは毎回取得する。
        width = getSize().width;
        height = getSize().height;
        
        g.setColor(Color.white); //背景色
        g.fillRect(0, 0, width, height);
        
        g.setColor(Color.black); //文字色
        draw_lines = height / font_height; //1画面の表示行を計算
        
        filesize = binfile.get_length();
        for (i = 0 ; i < draw_lines ; i++) {
            addr = start_line * 16 + i * 16;
            if (addr >= filesize)
                break;
            g.drawString(binfile.dispLine(addr), 0, baseline + font_height * i);
        }
    }
    
    //スクロールバーのイベントハンドラ
    class SymScroll implements AdjustmentListener  {
        public void adjustmentValueChanged(AdjustmentEvent evt) {
            Object obj = evt.getSource();
            
            if (obj == scrollbar) {
                Scrollbar bar = (Scrollbar)obj;
                int val = bar.getValue();
                
                start_line = val;
                drawHexDump(getGraphics());
                //repaint();
                
                //Bine.debugPrint(val);
            }
        }
    }
    
    void updateScrollValue(int line) {
        if (line < 0) {
            line = 0;   
        } else if (line > max_line - draw_lines) {
            line = max_line - draw_lines;  
        }
        start_line = line;
        scrollbar.setValue(start_line);
        updateWindow();
    }
    
    //スクロール用のキーイベントハンドラ
    class SymKey extends KeyAdapter {
        public void keyPressed(KeyEvent evt) {
            int code = evt.getKeyCode();
            
            //Bine.debugPrint(code);
            
            if (symkey == null)
                return;
            
            switch (code) {
            case KeyEvent.VK_PAGE_UP:   //PageUp キー
                updateScrollValue(start_line - block_line);
                break;
                
            case KeyEvent.VK_PAGE_DOWN: //PageDown キー
                updateScrollValue(start_line + block_line);
                break;
                
            case KeyEvent.VK_HOME: //Home キー
                updateScrollValue(0);
                break;
                
            case KeyEvent.VK_END: //End キー
                updateScrollValue(max_line - draw_lines);
                break;
                
            default:
                break;
            }
        }
    }
    
    
    /*
     * キー入力内部クラス
     */
    class KeyEdit extends KeyAdapter
    {
        public KeyEdit() {
        }
        
        //キーを離したときにアニメーションスレッドを再開させる
        public void keyReleased(KeyEvent evt) {
            animcursor.ready();
        }
        
        //カーソルの移動と編集
        public void keyPressed(KeyEvent evt) {
            int cy;
            
            //アニメーションスレッドを停止する
            animcursor.halt();
            
            moveCursor(evt);
            editCode(evt);
            
            //カーソル移動前後の領域に限定して再描画指示
            cy = cursor / 32;
            if (cy > 0) {
                cy--;
            }
            limitedUpdateWindow(0, cy * font_height, getSize().width, font_height * 3);
            
            //カーソルを表示
            animateCursor(offG);
        }
        
        void moveCursor(KeyEvent evt) {
            int code, caddr, savecursor;
            
            filesize = binfile.get_length();
            code = evt.getKeyCode();
            
            switch (code) {
            case KeyEvent.VK_UP:
                if (cursor - 32 >= 0) {
                    cursor -= 32;
                } else {
                    updateScrollValue(start_line - 1);
                }
                break;
            
            case KeyEvent.VK_DOWN:
                savecursor = cursor;
                
                if (cursor + 32 < filesize * 2) {
                    cursor += 32;
                }
                if (cursor / 32 > draw_lines - 1) {
                    cursor = savecursor;
                    updateScrollValue(start_line + 1);
                }
                break;
            
            case KeyEvent.VK_LEFT:
                if (cursor - 1 >= 0) {
                    cursor--;
                } else {
                    updateScrollValue(start_line - 1);
                }
                break;
            
            case KeyEvent.VK_RIGHT:
                cursor++;
                if (cursor / 32 > draw_lines - 1) {
                    cursor--;
                    updateScrollValue(start_line + 1);
                }
                break;
                
            case KeyEvent.VK_INSERT:
                overwritemode = !overwritemode;
                break;
            
            default:
                break;
            }
            
            if (cursor >= filesize * 2) {
                cursor = filesize * 2 - 1;
            }
            if (cursor < 0) {
                cursor = 0;
            }
            
        }
        
        //キーの読み取りとバイトコードの編集
        void editCode(KeyEvent evt) {
            char key = evt.getKeyChar();
            int caddr, lowbyte, n;
            byte value, newval;
            
            if (key >= '0' && key <= '9') {
                n = key - '0';   
            } else if (key >= 'a' && key <= 'f') {
                n = key - 'a' + 10;   
            } else if (key >= 'A' && key <= 'F') {
                n = key - 'A' + 10;   
            } else {
                n = -1;   
            }
            
            if (n == -1)
                return;
                
            caddr = start_line * 16 + cursor / 2;
            
            //上書きモードの場合
            if (overwritemode) {
                try {
                    value = binfile.getData(caddr);
                } catch (ArrayIndexOutOfBoundsException ex) {
                    //読み出し失敗
                    return;   
                }
                lowbyte = cursor & 1;
                
                if (lowbyte == 0) {
                    newval = (byte)(n << 4 | value & 0xf);
                } else {
                    newval = (byte)(value & 0xf0 | n & 0xf);
                }
                
                try {
                    binfile.setData(caddr, newval);
                } catch (ArrayIndexOutOfBoundsException ex) {
                    //編集失敗
                    return;   
                }
                
                parent.set_modified_window_caption();
                
            } else { //挿入モードの場合
                newval = (byte)(n << 4 | 0 & 0xf);
                
                try {
                    binfile.insertData(caddr, newval);
                } catch (ArrayIndexOutOfBoundsException ex) {
                    //編集失敗
                    return;   
                }
                
                parent.set_modified_window_caption();
            }
        }
        
    }
    
    class AnimateCursor extends Thread {
        volatile boolean stopThread = false;
        
        public void run() {
            while (true) {
                try {
                    Thread.sleep(CursorTimer);
                } catch(Exception e) {
                }
                
                if (!stopThread) {
                    animateCursor(offG);
                }
            }
        }
        
        synchronized void ready() {
            stopThread = false;
        }
        
        synchronized void halt() {
            stopThread = true;
        }
    }
    
    
    synchronized void animateCursor(Graphics g) {
        //カーソルの表示
        /*
            *cursor 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
            *       00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00
            *
            * アドレス部 = 10文字分 
            */
        int gx, gy;
            
        if (g == null)
            return;
            
        g.setColor(Color.black);
        g.setXORMode(Color.white);
        gx = font_width * 10 + (cursor % 32 + cursor / 2 % 16) * (font_width);
        gy = (cursor / 32) * font_height;
        if (overwritemode == false) { //挿入編集モード
            g.fillRect(gx, gy + font_height - 3, font_width, 3);
        } else { //上書き編集モード
            g.fillRect(gx, gy, font_width, font_height);
        }
        
        //再描画領域を限定して描画指示を出す。
        repaint(gx, gy, font_width, font_height);
    }
    
}

